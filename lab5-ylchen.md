#lab5
##练习1: 加载应用程序并执行（需要编码）

###设计实现过程
设置正确的trapframe内容，使得用户进程能从内核态返回用户态。  
1、tf_cs设置为USER_CS段  
2、tf_ds、tf_es、tf_ss设置为USER_DS段  
3、tf_esp设置为用户栈顶  
4、tf_eip为程序入口地址  
5、tf_eflags设置为开启中断  

###当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

1、wakeup_proc函数唤醒后该进程状态为PROC_RUNNABLE，被schedule函数选择，调用proc_run函数运行  
2、proc_run函数关闭中断，切换内核堆栈，修改页表基址寄存器cr3，调用switch_to函数切换通用寄存器信息，并将eip压栈，然后打开中断    
3、中断返回，从内核栈恢复eip，跳转到程序第一条指令处开始执行   


##练习2: 父进程复制自己的内存空间给子进程（需要编码）
###设计实现过程
1、找到新旧页地址  
2、调用memcpy函数复制页内容  
3、把新页地址写入pte  

###如何设计实现”Copy on Write 机制“

在Page结构体中，增加指示该页共享的标志。  
对该页执行写操作时，触发异常，分配新页，内容复制到新页中，并修改页表项和共享标志。  

##练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）
###fork/exec/wait/exit函数分析
fork函数创建与父进程相同的子进程，其主要功能为：分配PCB，内核栈，复制父进程的内存管理信息到子进程，复制父进程上下文到子进程，将子进程添加到进程列表，获取pid。   
创建过程中进程状态为uninitialized，创建完成后调用wakeup_proc唤醒新进程，状态变为runnable。  

exec函数加载elf格式应用程序并执行，其重要功能为：建立页表，复制代码段和数据段内容，建立用户堆栈和trapframe。
同样由wakeup_proc唤醒新进程进入runnable态。

wait函数使当前进程进入sleeping状态，其子进程进入zombie态后，对子进程做处理并回收子进程PCB，直到所有子进程运行完毕，重新回到runnable态。

exit函数使当前进程进入zombie态，回收页表等资源，若其父进程在等待，则唤醒父进程，后进行进程调度。

###请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

```
PROC_UNINIT <-- alloc_proc
    |
    |<--  proc_init/wakeup_proc
    |
    | PROC_ZOMBIE
    V  ↑<--  do_exit
PROC_RUNNABLE  <---------------------------
    |   ↑                 wakeup_proc -->|
    |  proc_run                           |
    |<-- try_free_pages/do_wait/do_sleep  |
    V                                     |
PROC_SLEEPING------------------------------
```

##与参考答案的区别
练习1：基本一致  
练习2：基本一致  
由于会产生make grade错误，注释了print_ticks函数。

##本实验中重要的知识点
###加载应用程序
加载应用程序时，需要为其建立页表，复制代码段和数据段内容，建立用户堆栈和trapframe等。这点与原理课讲述相似，增加了一些实用细节，比如通过填写trapframe，使得用户态运行的进程能返回到用户态。

###copy on write
原理与课程讲述一致，实验并没有实现此算法。

###进程状态
本次实验中阅读分析了进程状态切换的完整过程，包括切换的时机和所需操作等，与原理课讲述基本一致。

##OS原理中很重要，但在实验中没有对应上的知识点
###分析加载应用程序
实验中没有编写分析elf格式，程序堆栈建立和分配代码段、数据段等内容。

###wait系统调用
wait对于进程状态改变和子进程处理方面都比较复杂，实验中没有具体实现wait所需的操作。