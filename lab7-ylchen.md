#lab7

##练习1: 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）

###内核级信号量的设计描述及大致执行流流程
信号量由一个整型变量和两个原子操作组成。  
```
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```  
其中value为资源，wait_queue为等待此信号量的进程队列，两个原子操作为up和down。  
down操作中，首先关闭中断。如果满足value>0，则获得资源，value减1，然后打开中断；如果不满足，无法获得资源，将进程加入等待队列，打开中断，调度另一个进程运行，直至被up操作唤醒后退出队列。  
up操作中，首先关闭中断。如果wait_queue中没有等待的进程，则value加1，然后打开中断；如果有，唤醒第一个wait的进程，打开中断。

###给用户态进程/线程提供信号量机制的设计方案
在内核级信号量机制中，包含了一些需要内核级权限的操作，如开关中断、调度进程等，在用户态实现此机制时，可以将这些操作作为系统调用提供。   
此外，由于内核态的线程共享数据，而用户态进程不共享数据，因此需要特别将信号量设为共享数据。

##练习2: 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）

###内核级条件变量的设计描述，及大致执行流流程
```
typedef struct condvar{
    semaphore_t sem;        // the sem semaphore  is used to down the waiting proc, and the signaling proc should up the waiting proc
    int count;              // the number of waiters on condvar
    monitor_t * owner;      // the owner(monitor) of this condvar
} condvar_t;
```  
内核级条件变量由信号量、等待变量的进程数和指向管程的指针组成，其基本操作为cond_wait和cond_signal。  
cond_wait函数将自身进入等待状态，等待一个条件变量成立后继续运行。如果管程有等待的进程，则唤醒；如果没有，则释放管程锁。  
cond_signal函数唤醒等待条件变量的进程，如果没有等待则直接返回。

###给用户态进程/线程提供条件变量机制的设计方案 
条件变量在信号量的基础上实现，因此需满足之前所述信号量机制的设计方案，并将条件变量设置为进程间共享。

##与参考答案实现上的区别
练习二：基本一致

##本实验中重要的知识点

###信号量
信号量是一种同步互斥机制的实现，应用对象是在临界区中运行的时间较长的进程。当多个进程可以进行互斥或同步合作时，一个进程会由于无法满足信号量设置的某条件而在某一位置停止，直到它接收到一个特定的信号。  
实验在具体实现中采用了关中断的方式保证了对共享资源的互斥访问，通过等待队列让无法获得信号量的进程睡眠等待。

###管程与条件变量
一个管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作能同步进程和改变管程中的数据。管程相当于一个隔离区，每次只允许一个进程进入。  
为了避免忙等造成死锁，引入了条件变量，拥有一个进程的等待队列，可以使进程进入等待状态以及被唤醒。  
